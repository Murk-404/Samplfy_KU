import { readFileSync } from 'fs';

const displayHelp = ({
  defaultValues,
  options = new Map(),
  title = 'Usage',
  filePathArg
}) => {
  var _opts$;

  // Required properties first
  const opts = [...options.values()].sort((a, b) => a.required === b.required ? 0 : a.required ? -1 : 1);
  let str = title;

  if (opts.length > 0) {
    str += '\n\n';
  } // Maybe no option is required


  if ((_opts$ = opts[0]) !== null && _opts$ !== void 0 && _opts$.required) {
    str += 'Required\n';
  }

  let optionalFlag = true;
  const tab = '   ';
  opts.forEach(({
    name,
    description,
    required,
    shortFlag
  }, idx) => {
    const isLast = idx === opts.length - 1;
    const isBoolean = typeof defaultValues[name] === 'boolean';

    if (optionalFlag && !required) {
      str += 'Optional\n';
      optionalFlag = false;
    }

    str += `${tab}${shortFlag ? `${shortFlag}, ` : ''}`;
    str += `--${name}`;
    str += isBoolean ? '' : ` <${name}>`;
    str += ` [${typeof defaultValues[name]}]`;
    str += description ? `\n${tab}` + description : '';
    str += isLast ? '' : '\n\n';
  });

  if (filePathArg) {
    const {
      longFlag,
      description
    } = filePathArg;
    str += `\n\n${tab}${longFlag} [string]\n`;
    str += description ? `${tab}${description}\n` : '';
  }

  return str;
};

class ValidationError extends Error {
  constructor(err) {
    super(err);
    this.name = 'ValidationError';
    Object.setPrototypeOf(this, ValidationError.prototype);
  }

}

const allowedTypes = new Set(['string', 'number', 'boolean']);
function isSameType(type, reference) {
  return allowedTypes.has(type) && type === reference;
}
function parseJSONFile(path) {
  try {
    const file = readFileSync(path, {
      encoding: 'utf8'
    });
    return Object.entries(JSON.parse(file));
  } catch (error) {
    throw new ValidationError(`${path} is not a valid JSON file`);
  }
}

const requiredSym = Symbol('isRequired');
async function parseObjectLiteral({
  defaultValues,
  input,
  options = new Map()
}) {
  const requiredArgs = [...options.values()].filter(opts => opts.required);
  const config = new Map(Object.entries(defaultValues)); // For each required argument, replace its value temporarily
  // with a symbol

  requiredArgs.forEach(arg => {
    config.set(arg.name, requiredSym);
  });

  for (const [arg, argVal] of Object.entries(input)) {
    var _options$get;

    if (!config.has(arg)) continue;
    const customValidator = (_options$get = options.get(arg)) === null || _options$get === void 0 ? void 0 : _options$get.customValidator;

    if (customValidator) {
      // Coerced truthy values are ignored
      if (customValidator.isValid(argVal) === true) {
        config.set(arg, argVal);
      } else {
        throw new ValidationError(customValidator.errorMessage(argVal));
      }
    }

    const expected = typeof defaultValues[arg];
    const received = typeof argVal; // The received type must corresponds to the original type

    if (isSameType(expected, received)) {
      config.set(arg, argVal);
    } else {
      throw new ValidationError(`Invalid type for "${arg}". Expected ${expected}, got ${received}`);
    }
  } // Check if all required arguments have been defined or if the
  // temporary value is still there


  requiredArgs.forEach(arg => {
    if (config.get(arg.name) === requiredSym) {
      throw new ValidationError(`"${arg.name}" is required`);
    }
  }, []);
  return Object.fromEntries(config);
}

function transformOptions(parsingOptions) {
  if (!(parsingOptions !== null && parsingOptions !== void 0 && parsingOptions.options)) return new Map();
  return new Map(Object.entries(parsingOptions.options).reduce((acc, [name, opts]) => {
    if (!opts) return acc;
    acc.set(name, { ...opts,
      name
    });
    return acc;
  }, new Map()));
}
function transformArgv({
  argv,
  options = new Map(),
  filePathFlag
}) {
  const shortFlags = [...options.entries()].reduce((acc, [name, opts]) => {
    if (opts.shortFlag) acc[opts.shortFlag] = name;
    return acc;
  }, {});
  const map = argv.reduce((acc, curr, idx, orig) => {
    if (curr.startsWith('-') && Object.prototype.hasOwnProperty.call(shortFlags, curr)) {
      curr = '--' + shortFlags[curr];
    }

    if (curr.startsWith('--')) {
      const arg = curr.slice(2);
      const argVal = orig[idx + 1]; // Parse a file

      if ((filePathFlag === null || filePathFlag === void 0 ? void 0 : filePathFlag.slice(2)) === arg) {
        parseJSONFile(argVal).forEach(([key, content]) => acc.set(key, content));
      } // Assume boolean flag
      else if (!argVal || argVal.startsWith('-')) {
        acc.set(arg, true); // Assume number
      } else if (/^\d+$/.test(argVal)) {
        acc.set(arg, +argVal); // Assume string
      } else {
        acc.set(arg, argVal);
      }
    }

    return acc;
  }, new Map());
  return Object.fromEntries(map);
}

/**
 * Parser factory function. Returns a parser that is bound to the
 * given default values and options per key.
 *
 * @export
 */

function createParser(defaultValues, parsingOptions) {
  const options = transformOptions(parsingOptions);
  const filePathArg = parsingOptions === null || parsingOptions === void 0 ? void 0 : parsingOptions.filePathArg;
  return {
    help: function (title) {
      return displayHelp({
        defaultValues,
        options,
        title,
        filePathArg
      });
    },
    parse: function (input = []) {
      if (Array.isArray(input)) {
        input = transformArgv({
          argv: input,
          filePathFlag: filePathArg === null || filePathArg === void 0 ? void 0 : filePathArg.longFlag,
          options
        });
      }

      return parseObjectLiteral({
        defaultValues,
        input,
        options
      });
    }
  };
}

export { ValidationError, createParser };
